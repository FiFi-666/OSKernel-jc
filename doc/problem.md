# 遇到的问题


## 关于死锁

在某一次测试中，发现程序运行到某处后，进入了死循环。经过排查，发现，上一个测试程序的运行时产生了不正常的退出，而此时，这个程序仍然持有fat32文件系统的根目录的锁。故而，下一个测试程序会反复试图获得这个锁，但是它始终不能获取这个锁。

这个bug很容易就解决了。但是在后面，我思考如何才能避免这一问题，比如，下一次如何避免某一个程序再次试图获得某个已经结束的进程持有的锁？于是我想到了，可以定期检测锁的持有情况，如果发现它是被已经结束的进程持有，那么就可以释放这个锁。

于是我突然就想起来，操作系统课程中曾经讲过，处理死锁的一种方法是死锁检测，而教材中指出，linux操作系统选择的方法也正是死锁的检测。它允许死锁的出现，但是它会检测死锁，并解除它。

于是在这一刻，我突然体会到将理论上的知识与实践相结合的美妙。我再一次意识到，计算机科学正是在一次次解决问题中发展的。教材上的一句话，可能就是一群工程师或者科学家经过长时间讨论得出的方案。