# 本部分为系统内存管理

## 用户虚拟地址
![user_va](./pic/user_memory.png)

如图所示，上图为用户的虚拟地址空间，我们的操作系统实现的内容基本和linux操作系统的用户虚拟地址视图相同。下面分段描述每段内存的管理。

### 代码段，数据段，堆
这一部分，对于每一个进程都是私有的，并且在程序运行时，代码段和数据段的大小不会变动，只有堆的大小会变动。同时，堆是默认向上增长，故而我们考虑在每个进程的pcb中维护一个sz变量，指向当前进程的堆的最高端。

#### 堆的增长
堆的增长，一般是调用了brk或sbrk系统调用，这时我们查询对应的process的sz变量，再根据系统调用参数的要求，将sz扩大或减少，同时为进程建立完整的虚拟内存页面映射

### 栈
栈从用户内存虚拟地址的最高处MAXUVA开始向下递增。MAXUVA是内核中定义的一个常量。在进程初始化时，我们会为其默认分配一个INIT_STACK_SIZE大小的内存区域。

为了方便管理，我们设置了栈的内存在虚拟地址中的最小大小。为USER_STACK_DOWN，当栈往下增长到这个值时，会触发内核panic。至此，栈的大小被固定为256M。这在一定程度上会造成内存不足。但是我们当前遇到的应用程序尚未使用过如此大的栈区域。我们计划在之后内核遇到其他应用时，可以修改内核，继续扩增内核的栈空间。

栈是向下增长的，当栈指针sp向下增长到我们尚未分配到内存的位置时，会触发内核load page fault或 store page fault，这时，我们判断当前出发page fault地址是否在USER_STACK_DOWN和MAXUVA之间。如果是，我们分配新的内存页，并为其建立映射。之后返回用户程序。

### mmap 动态链接加载区域
在栈的下方，这块内存区域被内核用作mmap，动态链接文件的加载。

内核使用一种名为vma的结构体来管理这里的每段内存，vma使用双向链表的结构来进行管理。每当遇到mmap的需求时，我们使用vma结构记录当前需要分配的mmap区域的起始地址和大小，然后为其建立页表映射